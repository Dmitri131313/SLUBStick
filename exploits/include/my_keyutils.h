#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE
#endif
#include <sys/stat.h>
#include <asm/unistd.h>
#include "keyutils.h"
#include <limits.h>
#include <setjmp.h>
#include <pthread.h>

#include "utils.h"

char *keyring = "keyring";
#define KEY_SPEC_THREAD_KEYRING     -1  /* - key ID for thread-specific keyring */
#define KEY_SPEC_PROCESS_KEYRING    -2  /* - key ID for process-specific keyring */
#define KEY_SPEC_SESSION_KEYRING    -3  /* - key ID for session-specific keyring */
#define KEY_SPEC_USER_KEYRING       -4  /* - key ID for UID-specific keyring */
#define KEY_SPEC_USER_SESSION_KEYRING   -5  /* - key ID for UID-session keyring */
#define KEY_SPEC_GROUP_KEYRING      -6  /* - key ID for GID-specific keyring */
#define KEY_SPEC_REQKEY_AUTH_KEY    -7  /* - key ID for assumed request_key auth key */
#define KEYCTL_PKEY_QUERY       24  /* Query public key parameters */
#define KEYCTL_PKEY_ENCRYPT     25  /* Encrypt a blob using a public key */
#define KEYCTL_PKEY_DECRYPT     26  /* Decrypt a blob using a public key */
#define KEYCTL_PKEY_SIGN        27  /* Create a public key signature */
#define KEYCTL_PKEY_VERIFY      28  /* Verify a public key signature */
int _keyctl_pkey_encrypt(struct keyctl_pkey_params *params, const char *info, const char *input, const char *output)
{
    return syscall(SYS_keyctl, KEYCTL_PKEY_ENCRYPT, params, info, input, output);
}
int _keyctl_pkey_verify(struct keyctl_pkey_params *params, const char *info, const char *input, const char *input2)
{
    return syscall(SYS_keyctl, KEYCTL_PKEY_VERIFY, params, info, input, input2);
}

/**
 * for handle_fuse to execute the correct primitive
*/
#define DER_FILE_NAME "./data.der"
#define KEY_NAME "foo"
int key_id;
char *read_file(const char *name, size_t *len)
{
    ssize_t ret;
    int fd;
    char *data;

    fd = open(name, O_RDONLY);
    if (fd < 0)
        pr_perror("open(keyfile)");
    
    *len = lseek(fd, 0, SEEK_END);
    lseek(fd, 0, SEEK_SET);
    data = malloc(*len);
    memset(data, 0, *len);

    ret = read(fd, data, *len);
    if (ret != (ssize_t)*len)
        pr_perror("read(keyfile)");
    return data;
}
void do_keyctl_padd(void)
{
    size_t datalen;
    char *data;
    int ret;

    data = read_file(DER_FILE_NAME, &datalen);

    ret = add_key("asymmetric", KEY_NAME, data, datalen, KEY_SPEC_SESSION_KEYRING);
    if (ret < 0)
        pr_perror("add_key");

    key_id = ret;
    pr_info("key number %d\n", key_id);
}
