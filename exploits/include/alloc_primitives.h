#pragma once
#define _GNU_SOURCE
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/eventfd.h>
#include <errno.h>
#include <sys/timerfd.h>
#include <sys/socket.h>
#include <sys/signalfd.h>
#include <sys/prctl.h>

#include "utils.h"
#include "slab_settings.h"
#include "uhelper.h"

// ----------------------------------------------------------------------------
static inline size_t alloc_object_8(void)
{
    // __attribute__((unused))sigset_t mask = {};
    // int fd = signalfd(-1, &mask, 0);
    // if (fd < 0)
    //     pr_perror("signalfd4");
    // return fd;
    int fd = open("/proc/bus/pci/00/00.0", O_RDONLY);
    if (fd < 0)
        pr_perror("open(/proc/bus/pci/00/00.0)");
    return fd;

}
static inline void free_object_8(size_t object)
{
    close(object);
}

// ----------------------------------------------------------------------------
static inline size_t alloc_object_16(void)
{
    int fd = open("/sys/kernel/security/apparmor/revision", O_RDONLY);
    if (fd < 0)
        pr_perror("open(\"/sys/kernel/security/apparmor/revision\")");
    return fd;
}
static inline void free_object_16(size_t object)
{
    close(object);
}

// ----------------------------------------------------------------------------
static int shm_id;
static key_t mem_key;
static inline void init_object_32(void)
{
    mem_key = ftok(".", 'a');
    shm_id = shmget(mem_key, 4*sizeof(int), IPC_CREAT | 0666);
    if (shm_id < 0)
        pr_perror("shmget");
}
static inline size_t alloc_object_32(void)
{
    int *shm_ptr;
    shm_ptr = (int *)shmat(shm_id, NULL, 0);
    if ((int)shm_ptr == -1)
        pr_perror("shmat");
    return (size_t)shm_ptr;
}
static inline void free_object_32(size_t object)
{
    int ret = shmdt((void *)object);
    if (ret < 0)
        pr_perror("shmdt\n");
}

// ----------------------------------------------------------------------------
static inline size_t alloc_object_64(void)
{
    int fd = open("/dev/snd/controlC0", O_RDONLY);
    if (fd < 0)
        pr_perror("open(\"/dev/snd/controlC0\")");
    return fd;
}
static inline void free_object_64(size_t object)
{
    close(object);
}

// ----------------------------------------------------------------------------
static inline size_t alloc_object_96(void)
{
    int fd = open("/dev/vfio/vfio", O_RDONLY);
    if (fd < 0)
        pr_perror("open(\"/dev/vfio/vfio\")");
    return fd;
}
static inline void free_object_96(size_t object)
{
    close(object);
}

// ----------------------------------------------------------------------------
static inline size_t alloc_object_128(void)
{
    // dlm_user_proc requires device driver
    return -1;
}
static inline void free_object_128(__attribute__((unused))size_t object)
{

}

// ----------------------------------------------------------------------------
static inline size_t alloc_object_192(void)
{
    int fd = open("/sys/kernel/btf/ppdev", O_RDONLY);
    if (fd < 0)
        pr_perror("open(\"/sys/kernel/btf/ppdev\")");
    return fd;
}
static inline void free_object_192(size_t object)
{
    close(object);
}

// ----------------------------------------------------------------------------
static inline size_t alloc_object_256(void)
{
    // snd_compr_file requires device driver
    // vhci_data requires device driver
    return -1;
}
static inline void free_object_256(__attribute__((unused))size_t object)
{

}

// #define USE_MODULE
#ifdef USE_MODULE
#define init_alloc_primitives() do {} while (0)
#define alloc_object(i) do { int ret = alloc_obj(i, cur->size, 0); if (ret) pr_error("alloc object error\n"); } while (0)
#define free_object(i) do { int ret = free_obj(i); if (ret) pr_error("free object error\n"); } while (0)
#else
size_t *objects;
void **addresses;
#ifndef PR_SET_VMA
#define PR_SET_VMA 0x53564d41
#define PR_SET_VMA_ANON_NAME 0
#endif
int rename_vma(unsigned long addr, unsigned long size, char *name)
{
    int res;
    res = prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, addr, size, name);
    if (res < 0)
        pr_perror("prctl");
    return res;
}
char *free_name;
char *alloc_name;
size_t alloc_size;
size_t free_size;
/* works more reliable then the other allocation primitives */
void init_vma_name(void)
{
    pr_info("init addresses\n");
    
    switch (cur->size) {
        case 16:
            alloc_size = 8;
            free_size = 32;
            break;
        case 32:
            alloc_size = 16;
            free_size = 64;
            break;
        case 64:
            alloc_size = 32;
            free_size = 16;
            break;
        case 96:
            alloc_size = 64;
            free_size = 32;
            break;
        default:
            pr_error("invalid size\n");
    }
    free_name = malloc(free_size);
    memset(free_name, 0x41, free_size);
    free_name[free_size - 1] = 0;

    alloc_name = malloc(alloc_size);
    memset(alloc_name, 0x42, alloc_size);
    alloc_name[alloc_size - 1] = 0;

    addresses = malloc(2*cur->allocs*sizeof(void *));
    for (size_t i = 0; i < 2*cur->allocs; i++) {
        addresses[i] = mmap(0, (1ULL << 12), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (addresses[i] == MAP_FAILED)
            pr_perror("mmap");
    }
}
void vma_alloc(size_t i)
{
    memset(alloc_name, 0x42, alloc_size);
    alloc_name[alloc_size-1] = 0;
    char store[6];
    memset(store, 0, sizeof(store));
    snprintf(store, sizeof(store), "%05ld", i);
    memcpy(alloc_name, store, sizeof(store)-1);
    pr_debug("alloc_name %s len %ld\n", alloc_name, strlen(alloc_name));
    rename_vma((unsigned long) addresses[i], (1ULL << 12), alloc_name);
}
void vma_free(size_t i)
{
    memset(free_name, 0x44, free_size);
    free_name[free_size-1] = 0;
    char store[6];
    memset(store, 0, sizeof(store));
    snprintf(store, sizeof(store), "%05ld", i);
    memcpy(free_name, store, sizeof(store)-1);
    rename_vma((unsigned long) addresses[i], (1ULL << 12), free_name);
}

static inline void init_alloc_primitives(void)
{
    /* warmup + for slabs */
    objects = (size_t*)malloc(2*sizeof(size_t)*cur->allocs);
    memset(objects, -1, sizeof(size_t)*cur->allocs*2);
    switch (cur->size) {
        case 8:
            break;
        case 16:
            init_vma_name();
            break;
        case 32:
            init_vma_name();
            // init_object_32();
            break;
        case 64:
            init_vma_name();
            break;
        case 96:
            init_vma_name();
            break;
        case 128:
            break;
        case 192:
            break;
        case 256:
            break;
        default:
            break;
    }
}
static inline void alloc_object(size_t i)
{
    if (i >= cur->allocs*2)
        pr_error("alloc_object: index %zd too large\n", i);
    switch (cur->size) {
        case 8:
            alloc_obj(i, 256, 0);
            objects[i] = i;
            break;
        case 16:
            // vma_alloc(i);
            objects[i] = alloc_object_16();
            break;
        case 32:
            vma_alloc(i);
            // objects[i] = alloc_object_32();
            break;
        case 64:
            vma_alloc(i);
            // objects[i] = alloc_object_64();
            break;
        case 96:
            vma_alloc(i);
            // objects[i] = alloc_object_96();
            break;
        case 128:
            alloc_obj(i, 128, 0);
            objects[i] = i;
            break;
        case 192:
            objects[i] = alloc_object_192();
            break;
        case 256:
            alloc_obj(i, 256, 0);
            objects[i] = i;
            break;
        default:
            break;
    }
}
static inline void free_object(size_t i)
{
    if (i >= cur->allocs*2)
        pr_error("free_object: index %zd too large\n", i);
    switch (cur->size) {
        case 8:
            free_obj(i);
            break;
        case 16:
            // vma_free(i);
            free_object_16(objects[i]);
            break;
        case 32:
            vma_free(i);
            // free_object_32(objects[i]);
            break;
        case 64:
            vma_free(i);
            // free_object_64(objects[i]);
            break;
        case 96:
            vma_free(i);
            // free_object_96(objects[i]);
            break;
        case 128:
            free_obj(i);
            break;
        case 192:
            free_object_192(objects[i]);
            break;
        case 256:
            free_obj(i);
            break;
        default:
            break;
    }
    objects[i] = -1;
}
#endif
