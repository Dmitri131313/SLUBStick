#pragma once
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include "helper.h"
#include "utils.h"

static int fd;

int arb_write(size_t kaddr, size_t value)
{
	msg_t msg = {
		.wr = {
			.kaddr = kaddr,
			.value = value,
		}
	};
	return ioctl(fd, ARBRW_WRITE, (unsigned long)&msg);
}

int arb_read(size_t kaddr, size_t uaddr)
{
	msg_t msg = {
		.rd = {
			.kaddr = kaddr,
			.uaddr = uaddr,
		}
	};
	return ioctl(fd, ARBRW_READ, (unsigned long)&msg);
}

int arb_pagetable_walk(size_t uaddr, size_t *pgde, size_t *pude, size_t *pmde, size_t *pte)
{
	msg_t msg = {
		.ptw = {
			.uaddr = uaddr,
		}
	};
	int ret = ioctl(fd, ARBRW_PAGETABLE_WALK, (unsigned long)&msg);
	if (!ret) {
		if (pgde) *pgde = msg.ptw.pgd;
		if (pude) *pude = msg.ptw.pud;
		if (pmde) *pmde = msg.ptw.pmd;
		if (pte) *pte = msg.ptw.pte;
	}
	return ret;
}

void print_pagetable_walk(size_t uaddr)
{
	size_t pgde;
	size_t pude;
	size_t pmde;
	size_t pte;
    int ret = arb_pagetable_walk((size_t)uaddr, &pgde, &pude, &pmde, &pte);
    if (ret)
        pr_error("pagetable walk error\n");
    pr_info("addr %016zx pgde %016zx pude %016zx pmde %016zx pte %016zx\n", uaddr, pgde, pude, pmde, pte);
}

int alloc_obj(size_t id, size_t size, size_t uaddr)
{
	msg_t msg = {
		.obj = {
			.id = id,
			.size = size,
			.uaddr = uaddr,
		}
	};
	return ioctl(fd, ARBRW_OBJ_ALLOC, (unsigned long)&msg);
}

int alloc_accounted_obj(size_t id, size_t size, size_t uaddr)
{
	msg_t msg = {
		.obj = {
			.id = id,
			.size = size,
			.uaddr = uaddr,
		}
	};
	return ioctl(fd, ARBRW_OBJ_ALLOC_ACCOUNTED, (unsigned long)&msg);
}

int free_obj(size_t id)
{
	msg_t msg = {
		.obj = {
			.id = id,
		}
	};
	return ioctl(fd, ARBRW_OBJ_FREE, (unsigned long)&msg);
}

int read_obj(size_t id, size_t size, size_t uaddr)
{
	msg_t msg = {
		.obj = {
			.id = id,
			.size = size,
			.uaddr = uaddr,
		}
	};
	return ioctl(fd, ARBRW_OBJ_READ, (unsigned long)&msg);
}

int write_obj(size_t id, size_t size, size_t uaddr)
{
	msg_t msg = {
		.obj = {
			.id = id,
			.size = size,
			.uaddr = uaddr,
		}
	};
	return ioctl(fd, ARBRW_OBJ_WRITE, (unsigned long)&msg);
}

int alloc_and_copy_from_user(size_t size, size_t uaddr)
{
	msg_t msg = {
		.obj = {
			.size = size,
			.uaddr = uaddr,
		}
	};
	return ioctl(fd, ARBRW_ALLOC_AND_COPY_FROM_USER, (unsigned long)&msg);
}

void pin_to_core(size_t core)
{
    int ret;
    cpu_set_t cpuset;

    CPU_ZERO(&cpuset);
    CPU_SET(core, &cpuset);

    ret = sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);
    if (ret)
        pr_perror("setaffinity error\n");
}

void helper_init(void)
{
	fd = open("/dev/helper", O_RDWR);
	if (fd < 0)
		pr_perror("open(dev/helper)\n");
    // Assign to cpu 0
	pin_to_core(0);
}

void helper_init_no_pinning(void)
{
	fd = open("/dev/helper", O_RDWR);
	if (fd < 0)
		pr_perror("open(dev/helper)\n");
}
