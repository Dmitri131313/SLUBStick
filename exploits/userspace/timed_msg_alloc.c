#include "cacheutils.h"
#include "my_msgmsg.h"

#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/prctl.h>
#include <string.h>

#define MMAP_SIZE (1ULL << 10) * (1ULL << 10) * (1ULL << 10)
#define PAGE_SIZE (1 << 12)

#define ALLOCS 2048*4
static size_t times[ALLOCS];
int msqs[ALLOCS];

void timed_alloc_objs(size_t size, size_t *times)
{
    size_t t0;
    size_t t1;
    char buffer[0x2000] = {0};
    msg *message = (msg *)buffer;
    message->mtype = 0x41;
    int measure_spray = make_queue(IPC_PRIVATE, 00 | IPC_CREAT);
    pr_info("allocate %d objs\n", ALLOCS);
    for (size_t i = 0; i < ALLOCS; ++i) {
        sched_yield();
        msqs[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(msqs[i], message, size - 0x30, 0);
        t0 = rdtsc_begin();
        send_msg_no_err(measure_spray, message, size - 0x30, 0);
        t1 = rdtsc_end();
        times[i] = t1-t0;
    }
}

int main(int argc, char *argv[])
{
    static size_t generic_cache_size[] = {
        64, 96, 128, 192, 256, 512, 1024, 2048, 4096
    };
    size_t byte;
    size_t found = 0;

    if (argc != 2)
        pr_error("usage: %s <generic_cache_size>\n", argv[0]);
    byte = strtol(argv[1], 0, 10);

    for (size_t i = 0; i < sizeof(generic_cache_size)/sizeof(size_t); ++i)
        found |= (byte == generic_cache_size[i]);

    if (found == 0)
        pr_error("invalid byte\n");

    pr("start\n");

    pr("%ld bytes\n", byte);
    timed_alloc_objs(byte, times);

    pr("print times\n");
    wait_input();
    print_times(times, ALLOCS);

    pr("cleanup\n");
    for (size_t i = 0; i < ALLOCS; ++i)
        msgctl(msqs[i], IPC_RMID, 0);

    pr("done\n");
}