#include "utils.h"
#include "cacheutils.h"

#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/prctl.h>
#include <string.h>
#include <sys/time.h>
#include <sys/resource.h>
#include "keyutils.h"

#define PAGE_SIZE (1 << 12)

#define ALLOCS 2048*4//128
static size_t times[ALLOCS];

char *keyring = "keyring";
void timed_alloc_objs(size_t size, size_t *times)
{
    int ret;
    size_t t0;
    size_t t1;
    char *value;
    /* valid key name */
    char name[4096];

    /* invalid key -> measurement primitive */
    value = malloc(size);
    memset(value, 0x41, size);
    value[0] = '.';
    value[size - 1] = 0;
    *(volatile char *)keyring;

    pr_info("allocate %d objs\n", ALLOCS);
    for (size_t i = 0; i < ALLOCS; ++i) {
        sched_yield();
        snprintf(name, 4095, "%06lx", i);
        ret = open("/sys/kernel/btf/ppdev", O_RDONLY);
        if (ret < 0)
            pr_perror("open(/sys/kernel/btf/ppdev)\n");
        t0 = rdtsc_begin();
        ret = add_key(keyring, value, 0, 0, 0);
        t1 = rdtsc_end();
        if (ret >= 0)
            pr_perror("add_key should be an error\n");
        times[i] = t1-t0;
    }
}

int main(void)
{
    size_t byte = 192;
    int ret;
    struct rlimit l = {
        .rlim_cur = 63644,
        .rlim_max = 63644,
    };
    ret = setrlimit(RLIMIT_NOFILE, &l);
    if (ret < 0)
        pr_perror("setrlimit");

    pr("start\n");

    pr("%ld bytes\n", byte);
    timed_alloc_objs(byte, times);

    pr("print times\n");
    wait_input();
    print_times(times, ALLOCS);

    pr("done\n");
}