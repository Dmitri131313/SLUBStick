#include "utils.h"
#include "cacheutils.h"

#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/prctl.h>
#include <string.h>

#define PAGE_SIZE (1 << 12)

#define ALLOCS 2048*4
static size_t times[ALLOCS];
static void *addresses[2*ALLOCS];

#ifndef PR_SET_VMA
#define PR_SET_VMA 0x53564d41
#define PR_SET_VMA_ANON_NAME 0
#endif
int rename_vma(unsigned long addr, unsigned long size, char *name)
{
    int res;
    res = prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, addr, size, name);
    if (res < 0)
        pr_perror("prctl");
    return res;
}

void init_vma_name(void)
{
    pr_info("init addresses\n");
    for (int i = 0; i < 2*ALLOCS; i++) {
        addresses[i] = mmap(0, 1024, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (addresses[i] == MAP_FAILED)
            pr_perror("mmap");
    }
}

char *free_name;
void alloc_objs(size_t prev_size)
{
    pr_info("allocate %d objs\n", ALLOCS);
    char *buffer;
    buffer = malloc(prev_size);
    memset(buffer, 0x41, prev_size);
    buffer[prev_size - 1] = 0;
    free_name = malloc(prev_size);
    memset(free_name, 0x41, prev_size);
    free_name[prev_size - 1] = 0;
    for (size_t i = 0; i < ALLOCS; i++) {
        char store[5];
        memset(store, 0, 5);
        snprintf(store, 5, "%04ld", i);
        memcpy(buffer, store, 4);
        pr_debug("buffer %s len %ld\n", buffer, strlen(buffer));
        rename_vma((unsigned long) addresses[i], 1024, buffer);
    }
}

char *keyring = "keyring";
int add_key(const char *type, const char *description,
            const void *payload, size_t plen,
            int keyring)
{
    return syscall(SYS_add_key, type, description, payload, plen, keyring);
}

void timed_alloc_objs(size_t prev_size, size_t size, size_t *times)
{
    int ret;
    size_t t0;
    size_t t1;
    char *buffer;
    char *value;

    value = malloc(size);
    memset(value, 0x42, size);
    value[0] = '.';
    value[size - 1] = 0;
    *(volatile char *)keyring;

    buffer = malloc(prev_size);
    memset(buffer, 0x43, prev_size);
    buffer[prev_size - 1] = 0;
    
    pr_info("timed allocate %d objs\n", ALLOCS);
    for (size_t i = 0; i < ALLOCS; ++i) {
        char store[5];
        memset(store, 0, 5);
        snprintf(store, 5, "%04ld", i);
        memcpy(buffer, store, 4);
        pr_debug("buffer %s len %ld\n", buffer, strlen(buffer));
        rename_vma((unsigned long) addresses[i+ALLOCS], 1024, buffer);
        sched_yield();
        t0 = rdtsc_begin();
        ret = add_key(keyring, value, 0, 0, 0);
        t1 = rdtsc_end();
        times[i] = t1-t0;
        if (ret >= 0)
            pr_perror("add_key should be an error\n");
    }
}

int main(int argc, char *argv[])
{
    static size_t generic_cache_size[] = {
        8, 16, 32, 64, 96
    };
    size_t byte;
    size_t prev_byte;
    size_t found = 0;

    if (argc != 2)
        pr_error("usage: %s <generic_cache_size>\n", argv[0]);
    byte = strtol(argv[1], 0, 10);

    for (size_t i = 0; i < sizeof(generic_cache_size)/sizeof(size_t); ++i) {
        if (byte == generic_cache_size[i]) {
            found = 1;
            prev_byte = generic_cache_size[(i-1)];
            break;
        }
    }

    if (found == 0)
        pr_error("invalid byte\n");
    
    pr("start\n");
    init_vma_name();

    pr("%ld bytes\n", byte);
    alloc_objs(prev_byte);
    timed_alloc_objs(prev_byte, byte, times);

    pr("print times\n");
    wait_input();
    print_times(times, ALLOCS);

    pr("done\n");
}