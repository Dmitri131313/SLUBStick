#define FUSE_USE_VERSION 26

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <sys/uio.h>
#include <assert.h>
#include <stdlib.h>

#define FILE_TARGET "/timed_file"
#define FILE_SLOW_TARGET "/timed_slow_file"
#define FILE_VERY_SLOW_TARGET "/timed_very_slow_file"
#define SZ 8192

unsigned int file_size = 0;
unsigned int file_slow_size = 0;
unsigned int file_very_slow_size = 0;

char file_buffer[SZ];
char file_slow_buffer[SZ];
char file_very_slow_buffer[SZ];
static int fuse_getattr(const char *path, struct stat *stbuf)
{
    int res = 0;
    memset(stbuf, 0, sizeof(struct stat));
    if (!strcmp(path, "/")) {
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
    } else if (!strcmp(path, FILE_TARGET)) {
        stbuf->st_mode = S_IFREG | 0666;
        stbuf->st_nlink = 1;
        stbuf->st_size = file_size;
        stbuf->st_blocks = 0;
    } else if (!strcmp(path, FILE_SLOW_TARGET)) {
        stbuf->st_mode = S_IFREG | 0666;
        stbuf->st_nlink = 1;
        stbuf->st_size = file_slow_size;
        stbuf->st_blocks = 0;
    } else if (!strcmp(path, FILE_VERY_SLOW_TARGET)) {
        stbuf->st_mode = S_IFREG | 0666;
        stbuf->st_nlink = 1;
        stbuf->st_size = file_very_slow_size;
        stbuf->st_blocks = 0;
    } else {
        res = -ENOENT;
    }
    return res;
}

static int fuse_readdir(const char *, void *buf, fuse_fill_dir_t filler, off_t , struct fuse_file_info *)
{
    filler(buf, ".", NULL, 0);
    filler(buf, "..", NULL, 0);
    filler(buf, "timed_file", NULL, 0);
    filler(buf, "timed_slow_file", NULL, 0);
    filler(buf, "timed_very_slow_file", NULL, 0);
    return 0;
}

static int fuse_open(const char *, struct fuse_file_info *)
{
    return 0;
}

static int fuse_read(const char *path, char *buf, size_t size, off_t , struct fuse_file_info *)
{
    if (!strcmp(path, FILE_TARGET)) {
        sleep(2);
        memcpy(buf, file_buffer, size);
    } else if (!strcmp(path, FILE_SLOW_TARGET)) {
        sleep(8);
        memcpy(buf, file_slow_buffer, size);
    } else if (!strcmp(path, FILE_VERY_SLOW_TARGET)) {
        sleep(12);
        memcpy(buf, file_very_slow_buffer, size);
    }
    return size;
}

static int fuse_write(const char *path, const char *buf_to_write, size_t size, off_t offset, struct fuse_file_info *)
{
    if (!strcmp(path, FILE_TARGET)) {
        assert(offset <= SZ && (file_size + size) <= SZ);
        if(offset == 0) {
            memset(file_buffer, 0, SZ);
            file_size = 0;
        }
        memcpy(file_buffer+offset, buf_to_write, size);
        file_size += size;
    } else if (!strcmp(path, FILE_SLOW_TARGET)) {
        assert(offset <= SZ && (file_slow_size + size) <= SZ);
        if(offset == 0) {
            memset(file_slow_buffer, 0, SZ);
            file_slow_size = 0;
        }
        memcpy(file_slow_buffer+offset, buf_to_write, size);
        file_slow_size += size;
    } else if (!strcmp(path, FILE_VERY_SLOW_TARGET)) {
        assert(offset <= SZ && (file_very_slow_size + size) <= SZ);
        if(offset == 0) {
            memset(file_very_slow_buffer, 0, SZ);
            file_very_slow_size = 0;
        }
        memcpy(file_very_slow_buffer+offset, buf_to_write, size);
        file_very_slow_size += size;
    }
    return size;
}

static int fuse_setxattr(const char *, const char *, const char *, size_t , int )
{
    return 0;
}

static int fuse_truncate(const char *, off_t)
{
    return 0;
}

static int fuse_chmod(const char *, mode_t)
{
    return 0;
}

static int fuse_chown(const char *, uid_t, gid_t)
{
    return 0;
}

static int fuse_utimens(const char *, const struct timespec *)
{
    return 0;
}

static struct fuse_operations fuse_ops = {
    .getattr    = fuse_getattr,
    .readdir    = fuse_readdir,
    .open       = fuse_open,
    .read       = fuse_read,
    .write      = fuse_write,
    .setxattr   = fuse_setxattr,
    .truncate   = fuse_truncate,
    .chmod      = fuse_chmod,
    .chown      = fuse_chown,
    .utimens    = fuse_utimens
};

int main(int argc, char *argv[])
{
    return fuse_main(argc, argv, &fuse_ops, NULL);
}
