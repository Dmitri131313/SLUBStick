
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/sched.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/kprobes.h>
#include <linux/posix-timers.h>
#include <linux/hashtable.h>
#include <linux/rhashtable.h>
#include <linux/ipc_namespace.h>
#include <linux/futex.h>
#include <linux/mm_types.h>
#include <linux/rtmutex.h>
#include <linux/namei.h>
#include <linux/fs_struct.h>
#include <linux/path.h>
#include <linux/hash.h>
#include <asm/io.h>
#include <asm/word-at-a-time.h>
#include <linux/msg.h>
#include <linux/sched/mm.h>
#include "include/helper.h"

#define DEBUG_LVL 3

#if DEBUG_LVL > 3
#define debug_debug(FMT, ...) do {printk(KERN_DEBUG "[%-5.5s%5u] " FMT, current->comm, current->pid, ##__VA_ARGS__);} while (0)
#else
#define debug_debug(FMT, ...) do {} while (0)
#endif

#if DEBUG_LVL > 2
#define debug_info(FMT, ...) do {printk(KERN_INFO "[%-5.5s%5u] " FMT, current->comm, current->pid, ##__VA_ARGS__);} while (0)
#else
#define debug_info(FMT, ...) do {} while (0)
#endif

#if DEBUG_LVL > 1
#define debug_alert(FMT, ...) do {printk(KERN_ALERT "[%-5.5s%5u] " FMT, current->comm, current->pid, ##__VA_ARGS__);} while (0)
#else
#define debug_alert(FMT, ...) do {} while (0)
#endif

#if DEBUG_LVL > 0
#define debug_error(FMT, ...) do {printk(KERN_ERR "[%-5.5s%5u] " FMT, current->comm, current->pid, ##__VA_ARGS__);} while (0)
#else
#define debug_error(FMT, ...) do {} while (0)
#endif

#define DEVICE_NAME "helper"
#define CLASS_NAME "helperclass"

int helper_init_device_driver(void);
static int helper_init(void);
static void helper_cleanup(void);
int helper_open(struct inode *inode, struct file *filp);
int helper_release(struct inode *inode, struct file *filep);
long helper_ioctl(struct file *file, unsigned int num, long unsigned int param);

static struct file_operations helper_fops = {
	.owner = THIS_MODULE,
	.open = helper_open,
	.release = helper_release,
	.unlocked_ioctl = helper_ioctl,
};

static int helper_major;
static struct class *helper_class;
static struct device *helper_device;

static int bad_address(void *p)
{
	unsigned long dummy;

	return get_kernel_nofault(dummy, (unsigned long *)p);
}

static inline void invlpg(unsigned long addr)
{
    asm volatile("invlpg (%0)" ::"r" (addr) : "memory");
}

noinline void pagetable_walk(msg_t *msg)
{
	size_t address = msg->ptw.uaddr;
	pgd_t *base = __va(read_cr3_pa());
	pgd_t *pgd = base + pgd_index(address);
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *pte;

	if (bad_address(pgd))
		goto out;

	// pr_info("PGD %lx ", pgd_val(*pgd));
	msg->ptw.pgd = pgd_val(*pgd);
	if (!pgd_present(*pgd))
		goto out;

	p4d = p4d_offset(pgd, address);
	if (bad_address(p4d))
		goto out;

	// pr_cont("P4D %lx ", p4d_val(*p4d));
	msg->ptw.p4d = p4d_val(*p4d);
	if (!p4d_present(*p4d) || p4d_large(*p4d))
		goto out;

	pud = pud_offset(p4d, address);
	if (bad_address(pud))
		goto out;

	// pr_cont("PUD %lx ", pud_val(*pud));
	msg->ptw.pud = pud_val(*pud);
	if (!pud_present(*pud) || pud_large(*pud))
		goto out;

	pmd = pmd_offset(pud, address);
	if (bad_address(pmd))
		goto out;

	// pr_cont("PMD %lx ", pmd_val(*pmd));
	msg->ptw.pmd = pmd_val(*pmd);
	if (!pmd_present(*pmd) || pmd_large(*pmd))
		goto out;

	pte = pte_offset_kernel(pmd, address);
	if (bad_address(pte))
		goto out;

	// pr_cont("PTE %lx", pte_val(*pte));
	msg->ptw.pte = pte_val(*pte);

out:
	// pr_cont("\n");
	return;
}

/*
 * Initialization device driver
 */
int helper_init_device_driver(void)
{
	int ret;
	debug_info("helper:init_device_driver: start\n");

	ret = register_chrdev(0, DEVICE_NAME, &helper_fops);
	if (ret < 0) goto ERROR;
	helper_major = ret;

	helper_class = class_create(THIS_MODULE, CLASS_NAME);
	if (IS_ERR(helper_class)) {
		ret = PTR_ERR(helper_class);
		goto ERROR1;
	}

	helper_device = device_create(helper_class, 0, MKDEV(helper_major, 0), 0, DEVICE_NAME);
	if (IS_ERR(helper_device)) {
		ret = PTR_ERR(helper_device);
		goto ERROR2;
	}

	debug_info("helper:init_device_driver: done '/dev/%s c %d' 0 created\n", DEVICE_NAME, helper_major);
	return 0;

ERROR2:
	debug_alert("helper:init_device_driver: class destroy\n");
	class_unregister(helper_class);
	class_destroy(helper_class);
ERROR1:
	debug_alert("helper:init_device_driver: unregister chrdev\n");
	unregister_chrdev(helper_major, CLASS_NAME);
ERROR:
	debug_alert("helper:init_device_driver: fail %d\n", ret);
	helper_device = 0;
	helper_class = 0;
	helper_major = -1;
	return ret;
}

/*
 * Initialization
 */
static int helper_init(void)
{
	int ret;
	debug_info("helper:init: start\n");

	ret = helper_init_device_driver();
	if (ret) goto ERROR;

	debug_info("helper:init: helper_class            %016zx\n", (size_t)helper_class);
	debug_info("helper:init: helper_ioctl            %016zx\n", (size_t)helper_ioctl);
	debug_info("helper:init: done\n");
	return 0;

ERROR:
	debug_alert("helper:init: error\n");
	return ret;
}

/*
 * Cleanup
 */
static void helper_cleanup(void)
{
	debug_info("helper:cleanup\n");
	device_destroy(helper_class, MKDEV(helper_major, 0));
	class_unregister(helper_class);
	class_destroy(helper_class);
	unregister_chrdev(helper_major, DEVICE_NAME);
}

/*
 * Close "/dev/helper"
 */
int helper_release(struct inode *inode, struct file *filep)
{
	debug_info("helper:release\n");
	module_put(THIS_MODULE);
	return 0;
}
EXPORT_SYMBOL(helper_release);

/*
 * Open "/dev/helper"
 */
int helper_open(struct inode *inode, struct file *filp)
{
	debug_info("helper:open\n");
	try_module_get(THIS_MODULE);
	return 0;
}
EXPORT_SYMBOL(helper_open);

/*
 * ioctl code
 */
static void *objs[(1 << 18)];
long helper_ioctl(struct file *_, unsigned int num, long unsigned int param)
{
	long ret;
	msg_t msg;
	size_t *uaddr = 0;
	size_t size;
	size_t id;
	size_t tmp = -1;
	void *obj;
	static char buf[PAGE_SIZE];
	debug_debug("helper:ioctl: start num 0x%08x param 0x%016lx\n", num, param);

	ret = copy_from_user((msg_t*)&msg, (msg_t*)param, sizeof(msg_t));
	if (ret < 0) {
		debug_alert("helper:ioctl: copy_from_user failed\n");
		ret = -1;
		goto RETURN;
	}

	switch (num) {
		case ARBRW_WRITE:
			debug_debug("arbrw:ioctl: arbitrary write\n");
			*(size_t *)msg.wr.kaddr = msg.wr.value;
			break;

		case ARBRW_READ:
			debug_debug("arbrw:ioctl: arbitrary read\n");
			tmp = *(size_t *)msg.rd.kaddr;
			uaddr = (size_t *)msg.rd.uaddr;
			goto COPY_TMP_TO_USER;

		case ARBRW_PAGETABLE_WALK:
			debug_debug("arbrw:ioctl: page table walk\n");
			msg.ptw.pgd = 0;
			msg.ptw.p4d = 0;
			msg.ptw.pud = 0;
			msg.ptw.pmd = 0;
			msg.ptw.pte = 0;
			pagetable_walk(&msg);
			ret = copy_to_user((msg_t*)param, (msg_t*)&msg, sizeof(msg_t));
			if (ret < 0) {
				debug_alert("arbrw:ioctl: copy_to_user failed\n");
				ret = -1;
				goto RETURN;
			}
			break;

		case ARBRW_LEAK_KASLR:
			debug_debug("arbrw:ioctl: leak kaslr\n");
			tmp = (size_t)&vfs_create & ~0xfffff;
			uaddr = (size_t *)msg.rd.uaddr;
			goto COPY_TMP_TO_USER;

		case ARBRW_OBJ_ALLOC:
			id = msg.obj.id;
			size = msg.obj.size;
			uaddr = (size_t *)msg.obj.uaddr;
			debug_debug("arbrw:ioctl: obj alloc id %08zx size %016zx\n", id, size);
			objs[id] = kmalloc(size, GFP_KERNEL);
			debug_debug("arbrw:ioctl: objs[id] %016zx\n", (size_t)objs[id]);
			if (uaddr) {
				tmp = (size_t)objs[id];
				goto COPY_TMP_TO_USER;
			}
			break;

		case ARBRW_OBJ_ALLOC_ACCOUNTED:
			id = msg.obj.id;
			size = msg.obj.size;
			uaddr = (size_t *)msg.obj.uaddr;
			debug_debug("arbrw:ioctl: obj alloc accounted id %08zx size %016zx\n", id, size);
			objs[id] = kmalloc(size, GFP_KERNEL_ACCOUNT);
			debug_debug("arbrw:ioctl: objs[id] %016zx\n", (size_t)objs[id]);
			if (uaddr) {
				tmp = (size_t)objs[id];
				goto COPY_TMP_TO_USER;
			}
			break;
		case ARBRW_OBJ_FREE:
			id = msg.obj.id;
			debug_debug("arbrw:ioctl: obj free id %08zx objs[id] %016zx\n", id, (size_t)objs[id]);
			kfree(objs[id]);
			break;

		case ARBRW_OBJ_READ:
			id = msg.obj.id;
			size = msg.obj.size;
			uaddr = (size_t *)msg.obj.uaddr;
			debug_debug("arbrw:ioctl: obj read id %08zx size %016zx uaddr %016zx\n", id, size, (size_t)uaddr);
			ret = raw_copy_to_user(uaddr, objs[id], size);
			if (ret < 0) {
				debug_alert("arbrw:ioctl: copy_to_user failed\n");
				ret = -1;
				goto RETURN;
			}
			break;

		case ARBRW_OBJ_WRITE:
			id = msg.obj.id;
			size = msg.obj.size;
			uaddr = (size_t *)msg.obj.uaddr;
			debug_debug("arbrw:ioctl: obj write id %08zx size %016zx uaddr %016zx\n", id, size, (size_t)uaddr);
			ret = copy_from_user(buf, uaddr, size);
			if (ret < 0) {
				debug_alert("arbrw:ioctl: copy_from_user failed\n");
				ret = -1;
				goto RETURN;
			}
			memcpy(objs[id], buf, size);
			break;

		case ARBRW_ALLOC_AND_COPY_FROM_USER:
			size = msg.obj.size;
			uaddr = (size_t *)msg.obj.uaddr;
			debug_debug("arbrw:ioctl: write user data to malloc with size %zx\n", size);
			obj = kmalloc(size, GFP_KERNEL);
			ret = copy_from_user(obj, uaddr, size);
			if (ret < 0) {
				debug_alert("arbrw:ioctl: copy_from_user failed\n");
				ret = -1;
				goto RETURN;
			}
			break;

		default:
			debug_alert("helper:ioctl: no valid num\n");
			ret = -1;
			goto RETURN;
	}
	ret = 0;
	goto DONE;
COPY_TMP_TO_USER:
	BUG_ON(uaddr == 0 && "forgot to set uaddr");
	BUG_ON(tmp == -1 && "forgot to set tmp");
	debug_debug("helper:ioctl: copy 0x%016zx to mem[0x%016zx]\n", tmp, (size_t)uaddr);
	ret = copy_to_user(uaddr, &tmp, sizeof(size_t));
	if (ret < 0) {
		debug_alert("helper:ioctl: copy_to_user failed\n");
		ret = -1;
		goto RETURN;
	}
	ret = 0;

DONE:
	debug_debug("helper:ioctl: done\n");
RETURN:
	return ret;
}
EXPORT_SYMBOL(helper_ioctl);

module_init(helper_init);
module_exit(helper_cleanup);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Lukas Maar");
MODULE_DESCRIPTION("LKM");
MODULE_VERSION("0.1");
